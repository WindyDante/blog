# 概念

操作系统(Operating System，OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件

1. 操作系统是系统资源的管理者
2. 向上层提供方便易用的服务
3. 是最接近硬件的一层软件

执行一个程序前需要将该程序放到内存中，才能被CPU处理

<img src="https://b.1wind.cn/2025/08/af76489d201ffaf9a24533f5904b578b.png" alt="image-20250806215335149" style="zoom:50%;" />

<img src="https://b.1wind.cn/2025/08/e8776ac541fad664900cfa100f35d3d2.png" alt="image-20250806215527318" style="zoom:50%;" />

<img src="https://b.1wind.cn/2025/08/6505940bf873d689e7f6352c48f2e044.png" alt="image-20250806215854046" style="zoom: 50%;" />

没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器

通常把覆盖了软件的机器称为扩充机器，又称为虚拟机

# 特征

## 并发&共享

并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的。但微观上是交替发生的

常考易混概念---并行：指两个或多个事件在同一时刻同时发生

并发其实可以这么理解，某一个时间段，你在做一件事情，炒菜，但炒菜这里包含多个工作，它是交替执行的，比如说8点切菜，9点烧菜，从宏观上看，它只在做一件事，炒菜，但从微观上看，这些动作是交替的

而并行就是说，8点炒菜并烧菜，这两个工作一起干，而不是分开干

操作系统的并发性指计算机系统中“同时”运行多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的

操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的

注意**(重要考点)**：

单核CPU同一时刻只能执行一个程序，各个程序只能并发执行

多核CPU同一时刻可以同时执行多个程序，多个程序可以并行执行

共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用

- 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段只允许一个进程访问该资源
- 同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问

并发性指计算机系统中同时存在多个运行着的程序

共享性是指系统中的资源可供内存中多个并发执行的进程共同使用

**并发性和共享性互为共存条件**

## 虚拟

虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的

可以这么理解，硬盘在电脑中是真实存在的，而硬盘分盘是一种逻辑上的分盘操作，并没有真实的把硬盘分割成几个小硬盘

## 异步

异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性

系统资源可能因某种情况而阻塞导致程序并不是同步的运行过去，而是异步的不按规定去运行

如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性

# 发展&分类

## 手工操作阶段

程序猿将程序[二进制]写到纸带上，然后将纸带装到纸带机上，接着计算机需要将纸带机的数据读取，并给出纸带结果，最终程序猿需要取走纸带

主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低

## 批处理阶段

### 单道批处理系统

引入脱机输入/输出技术(用外围机+磁带完成)，并由监督程序负责控制作业的输入、输出【操作系统的雏形】

主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升

主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/0完成。资源利用率依然很低

### 多道批处理系统

操作系统正式诞生，用于支持多道程序并发运行，每次往内存中读入多道程序

主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。

主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。）

eg：无法调试程序/无法在程序运行过程中输入一些参数

## 分时操作系统

分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互

主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性

## 实时操作系统

主要优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队

在实时操作系统的控制下，计算机系统接收到外部新号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性

实时操作系统分为硬实时系统和软实时系统

- 硬实时系统：必须在绝对严格的规定时间内完成处理
- 软实时系统：能接受偶尔违反时间规定

## 其他操作系统

网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）

分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务

个人计算机操作系统：如Windows XP、MacOS，方便个人使用

# 运行机制

我们普通程序员写的程序就是“应用程序”

微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”

由很多内核程序组成了“操作系统内核”，简称“内核(Kernel)”

内核是操作系统最重要最核心的部分，也是最接近硬件的部分

甚至可以说，一个操作系统只要有内核就够了(eg：Docker->仅需Linux内核)

操作系统的功能未必都在内核中，如图形化用户界面GUI

- 应用程序只能使用“非特权指令”，如：加法、减法指令等
- 操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。
- 这些指令影响重大，只允许管理者---即操作系统内核来使用

在**CPU设计和生产的时候就划分了特权指令和非特权指令**，因此CPU执行一条指令前就能判断出其类型

CPU有两种状态，“内核态”和“用户态”

- 处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令
- 处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令
- 拓展：CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示“内核态”，0表示“用户态”
- 别名：内核态=核心态=管态；用户态=目态

内核态->用户态：执行一条特权指令---修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权

用户态->内核态：由“中断”引发，硬件自动完成转变过程，触发中断信号意味着操作系统将强行夺回CPU的使用权

除了非法使用特权指令之外，还有很多事件会触发中断信号，**一个共性是，但凡需要操作系统介入的地方，都会触发中断信号**

操作系统运行机制

1. 刚开机时，CPU为**内核态**，操作系统内核程序先上CPU运行
2. 开机完成后，用户可以启动某个应用程序
3. 操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行
4. 应用程序运行在用户态
5. 此时，黑客在应用程序中植入了一条特权指令，企图破坏系统
6. CPU发现接下来要执行的这条指令是特权指令，但是自己又处于用户态
7. 这个非法事件会引发一个**中断信号**
8. 中断使操作系统再次夺回CPU的控制权
9. 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序

操作系统内核在让出CPU之前，**会用一条特权指令把PSW的标志位设置为用户态**

**CPU检测到中断信号后，会立即变为“核心态”**，并停止运行当前的应用，转而运行处理中断信号的内核程序

# 中断&异常

## 中断的作用

中断会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权

CPU上会运行两种程序，一种是操作系统内核程序(是整个系统的管理者)，一种是应用程序

在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序

“中断”是让操作系统内核夺回CPU使用权的唯一途径

如果没有中断机制，那么一旦应用程序上CPU运行，CPU就会一直运行在这个应用程序

## 中断的类型

内中断：与当前执行的指令有关，中断信号来源于CPU内部

eg：

1. 试图在用户态下执行特权指令
2. 执行除法指令时发现除数为0(若当前执行的指令是非法的，则会引发一个中断信号)
3. 有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令---陷入指令，该指令会引发一个内部中断的信号(执行陷入指令，意味着应用程序主动地将CPU控制器还给操作系统内核。系统调用就是通过陷入指令完成的)

外中断：与当前执行的指令无关，中断信号来源于CPU外部

eg：

1. 时钟中断---由时钟部件发来的中断信号(时钟部件每隔一个时间片(如50ms)会给CPU发送一个时钟中断信号)
2. I/0中断---由输入/输出设备发来的中断信号(当输入输出任务完成时，向CPU发送中断信号)

## 中断的分类

内中断也称异常、例外

内中断由陷阱(陷入)、故障、终止组成

- 陷阱(陷入)：由陷入指令引发，是应用程序故意引发的
- 故障：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去
- 终止：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0、非法使用特权指令

外中断也称中断

外中断包括但不限于时钟中断、I/0中断请求

## 中断的基本原理

不同的中断信号，需要不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置

如图所示

<img src="https://b.1wind.cn/2025/08/3f92879160c33a50446cc388af9bb733.png" alt="image-20250810100536411" style="zoom:50%;" />

# 系统调用

操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组**系统调用**组成

系统调用是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，**应用程序可以通过系统调用来**请求获得操作系统内核的服务

| 普通应用程序 | 可直接进行系统调用，也可以使用库函数，有的库函数涉及系统调用，有的不涉及 |
| ------------ | ------------------------------------------------------------ |
| 编程语言     | 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便 |
| 操作系统     | 向上提供系统调用，使得上层程序能请求内核的服务               |
| 裸机         |                                                              |

<img src="https://b.1wind.cn/2025/08/d0873231aa910692fe22dc46fcdab0a6.png" alt="image-20250810101639955" style="zoom:50%;" />

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作(如存储分配、I/0操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作

系统调用按功能分类:

1. 设备管理:完成设备的 请求/释放/启动 等功能
2. 文件管理：完成文件的 读/写/创建/删除 等功能
3. 进程控制：完成进程的 创建/撤销/阻塞/唤醒 等功能
4. 进程通信：完成进程之间的 消息传递/信号传递 等功能
5. 内存管理：完成内存的 分配/回收 等功能

# 体系结构

## 概念

计算机系统层次结构如图所示

![image-20250810135929538](https://b.1wind.cn/2025/08/694dc1117cf4620eac5602d5b015dd4a.png)

**内核**是操作系统最基本、最核心的部分

实现操作系统内核功能的那些程序就是**内核程序**

- 内核
	- 时钟管理：实现计时功能
	- 中断处理：负责实现中断机制
	- 原语：
		- 是一种特殊的程序
		- 处于操作系统最底层，是最接近硬件的部分
		- 这种程序的运行具有原子性---其运行只能一气呵成，不可中断
		- 运行时间较短，调用频繁
	- 对系统资源进行管理的功能
		- 进程管理
		- 存储器管理
		- 设备管理

内核也分为大内核以及微内核

- 大内核
	- 将操作系统的主要功能模块都作为系统内核，运行在核心态
	- 优点：高性能
	- 缺点：内核代码庞大，结构混乱，难以维护
- 微内核
	- 只把最基本的功能保留在内核
	- 优点：内核功能少，结构清晰，方便维护
	- 缺点：需要频繁地在核心态和用户态之间切换，性能低

典型的大内核/宏内核/单内核 操作系统：Linux、UNIX

典型的微内核 操作系统：Windows NT

<img src="https://b.1wind.cn/2025/08/6d349778908a35d0a5550b54a20bd68c.png" alt="image-20250810142118058" style="zoom:50%;" />

如图所示

大内核中将系统的主要功能存储在内核态中,应用程序存储在用户态中

微内核只保留了最基本的功能在内核态中,其余的都在用户态中

## 总结图

![image-20250810142422270](https://b.1wind.cn/2025/08/082d6c316c7d11acdd95578a18fdd179.png)

# 引导

操作系统引导(boot)---开机的时候，怎么让操作系统运行起来？

如图所示

![image-20250810145237909](https://b.1wind.cn/2025/08/d464664196dfdab70eca2aaa1481ff1c.png)

操作系统引导：

1. CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序(先进行硬件自检,再开机)
2. 将磁盘的第一块---主引导记录读入内存,执行磁盘引导程序,扫描分区表
3. 从活动分区(又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序
4. 从根目录下找到完整的操作系统初始化程序(即启动管理器)并执行，完成“开机”的一系列动作

# 虚拟机

虚拟机，使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM)，每个虚拟机器都可以独立运行一个操作系统

同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor

如图所示

![image-20250810154031211](https://b.1wind.cn/2025/08/0c263558053b3e8577f88c54359d1075.png)

对比如下

第一类简单来说就是多系统了,第二类是运行在某种虚拟程序上,比如vmware

![image-20250810155402104](https://b.1wind.cn/2025/08/e6ccebd494c0941f394c96f911a16ebc.png)

# 进程

## 概念

程序：是静态的，就是存放在磁盘里的可执行文件，一系列的指令集合

进程：(Process)：是动态的，是程序的一次执行过程

## 组成

当进程被创建时，操作系统会为该进程分配一个**唯一的、不重复**的“身份证号”---PID（Process ID,进程ID）

操作系统要记录PID、进程所属用户ID(基本的进程描述信息，可以让操作系统区分各个进程)

（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件[可用于实现操作系统对进程的控制、调度]）

还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等[可用于实现操作系统对进程的控制、调度]）

这些信息都被保存在一个数据结构PCB（Process Control Block）中，即**进程控制块**

操作系统需要对各个并发运行的进程进行管理，但凡管理时需要的信息，都会被放在PCB中

PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会收回其PCB

一个**进程实体(进程映像)**由**PCB(进程控制块)、程序段(包含程序指令)、数据段(包含运行过程中产生的各种数据)**组成

**进程是动态的**，进程实体(进程映像)是静态的

进程实体反应了进程在某一时刻的状态(如:x++后，x=2)

## 特征

- 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的
- 并发性：内存中有多个进程实体，各进程可并发执行
- 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
- 异步性：各进程是按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题
- 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

## 状态&转换

- 进程正在被创建时，它的状态是“**创建态**”，在这个阶段操作系统会为进程分配资源、初始化PCB
- 当进程创建完成后，便进入“就绪态”，处于就绪态的进程已经具备运行条件，但由于没有空闲的CPU，就暂时不能运行

- 如果一个进程此时在CPU上运行，那么这个进程处于“**运行态**”
- CPU会执行该进程对应的程序(执行指令序列)

- 在进程运行的过程中，可能会**请求等待某个事件的发生**(如等待某种系统资源的分配，或者等待其他进程的响应)
- 在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入**阻塞态**
- 当CPU空闲时，又会选择另一个就绪态进程上CPU运行

- 一个进程可以执行exit系统调用，请求操作系统终止该进程。
- 此时该进程会进入“**终止态**”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB

![image-20250811220223814](https://b.1wind.cn/2025/08/156dbf5cf75a501b570a55875aab3b4a.png)

状态转换图如上

- 运行态:占有CPU,并在CPU上运行(单CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态)
- 就绪态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
- 阻塞态(等待态)：因等待某一事件而暂时不能运行
- 创建态(新建态)：进程正在被创建，操作系统为进程分配资源，初始化PCB
- 终止态(结束态)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

## 控制

### 概念

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能

简化理解：反正进程控制就是要实现进程状态转换

原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断

可以用`关中断指令`和`开中断指令`这两个特权指令实现原子性

CPU执行了`关中断指令`之后，就不再例行检查中断信号，直到执行`开中断指令`之后才会恢复检查

### 相关的原语

<img src="https://b.1wind.cn/2025/08/0a1f79368249cad23e4a81abb687dd09.png" alt="image-20250812102737653" style="zoom:50%;" />

<img src="https://b.1wind.cn/2025/08/1c56cb1d6423143c675da6e4bc076e30.png" alt="image-20250812102846503" style="zoom:50%;" />

<img src="https://b.1wind.cn/2025/08/f5e433b3d1d43ef49b3fb226e5731c2e.png" alt="image-20250812103518269" style="zoom:50%;" />

<img src="https://b.1wind.cn/2025/08/4b74a515677c96f523211fece1fa9a93.png" alt="image-20250812103650620" style="zoom:50%;" />

## 通信(IPC)

### 概念

进程间通信(Inter-Process Communication,IPC)是指两个进程之间产生数据交互

进程是分配系统资源的单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立

### 共享存储

基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级的通信方式

基于存储区的共享：操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式

### 消息传递

进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换

消息发送需要消息头和消息体

其中消息头包括：

- 发送进程ID
- 接收进程ID
- 消息长度等格式化的信息

而消息传递有两种方式

- 直接通信方式
- 间接通信方式

通过“信箱”间接的通信，因此又被称为信箱通信方式

![image-20250812153455651](https://b.1wind.cn/2025/08/2a6bfe1545a06b2c992c3c00683cf037.png)

直接通信方式如上图所示

<img src="https://b.1wind.cn/2025/08/21808594912c66c380643bbd3a002d7a.png" alt="image-20250812154030993" style="zoom:50%;" />

间接通信通信方式如上图所示

### 管道通信

![image-20250812155653070](https://b.1wind.cn/2025/08/8026964f523089805489e567c96887a4.png)

管道是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区

- 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道
- 各进程要互斥地访问管道(由操作系统实现)
- 当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程
- 当管道读空时，读进程将阻塞，直到写进程往管道内写入数据，即可唤醒读进程
- 管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案
	- 一个管道允许多个写进程，一个读进程(考试选这个)
	- 允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据

- 写进程往管道写数据，即便管道没被写满，只要管道没空，读进程就可以从管道读数据
- 读进程从管道读数据，即便管道没被读空，只要管道没满，写进程就可以往管道写数据

## 挂起状态&七状态模型

暂时调到外存等待的进程状态为**挂起状态(挂起态，suspend)**

挂起态又可以进一步细分为**就绪挂起、阻塞挂起**两种状态

![image-20250813160146674](https://b.1wind.cn/2025/08/07a94e5cfa2284a84ed15a975d45b841.png)

七状态模型如上图所示

注意**挂起**和**阻塞**的区别，两种状态都是暂时不能获取CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中

有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列



# 信号

- 信号量(Semaphore)---实现进程间的同步、互斥
- 信号(Signal)---实现进程间通信(IPC,Inter Process Communication)

信号是用于**通知进程某个特定事件已经发生**。**进程收到一个信号后，对该信号进行处理**

注1：不同的操作系统对信号类型的定义不一样

注2：通常用宏定义常量表示信号名，如：#define SIGINT 2



**When 什么时候处理信号？**

- 当用户从内核态转为用户态时(如：系统调用返回、或中断处理返回时)，例行检查是否有待处理信号，如果有，就处理信号



**How 怎么处理信号？**

1. 执行操作系统为此类信号设置的缺省**(默认)信号处理程序**(**某些信号默认忽略，不作处理**)
2. 执行进程为此类信号设置**用户自定义信号处理程序(自定义信号处理程序将覆盖①)**

- 信号处理程序运行结束后，通常会返回进程的下一条指令继续执行(除非信号处理程序将进程阻塞或终止)
- 一旦处理了某个信号，就将pending位重置位0
- 重复收到的同类信号，将被简单地丢弃（因为仅有1bit记录一类待处理信号）
- 当同时收到多个不同类信号时，通常先处理序号更小的信号



信号可以作为异常的配套机制，让进程对操作系统的异常处理进行补充

在进程运行过程中，某些特殊事件可能引发“异常”，操作系统内核负责捕获并处理异常

- 有些异常可以由内核完成全部处理，此时就不必再使用信号机制
- 有些异常无法由内核完成全部处理，可能还需要用户进程配合，此时就可以用“信号机制”与”异常机制“相互配合（如：在Linux中，会发生**除以0异常**时，内核的异常处理程序会向用户进程发送SIGFPE信号。SIGFPE信号的默认处理程序会终止并转储内存；当然进程可以自定义SIGFPE信号处理程序）

# 线程

## 概念 

可以把线程理解为“轻量级进程”

线程是一个基本的CPU执行单元，也是程序执行流的最小单位

引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务(如QQ视频、文字聊天、传文件)

引入线程后，进程只作为除CPU之外的系统资源的分配单元(如打印机、内存地址空间等都是分配给进程的)

## 特点

**引入线程机制后带来的变化**

- 资源分配、调度
	- 传统进程机制中，进程是资源分配、调度的基本单位
	- 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
- 并发性
	- 传统进程机制中，只能进程间并发
	- 引入线程后，各线程间也能并发，提升了并发度
- 系统开销
	- 传统的进程间并发，需要切换进程的运行环境，系统开销很大
	- 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
	- 引入线程后，并发所带来的系统开销减小

**属性**

- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块(TCB)
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程的资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统开销较大

## 实现方式

### 用户级线程

1. 用户级线程由应用程序通过线程库实现，所有的线程管理各种都由应用程序负责(包括线程切换)
2. 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预
3. 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在

“用户级线程”就是“从用户视角可以看到的线程”

- 优缺点
	- 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
	- 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

### 内核级线程

1. 内核级线程的管理工作由操作系统内核完成
2. 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成
3. 操作系统会为每个内核级线程建立相应的TCB(Thread Control Block，线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角能看到的线程”

- 优缺点
	- 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程还在多核处理机上并行执行
	- 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

## 多线程模型

**一对一**模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大



**多对一**模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

**重点**：操作系统只`看得见`内核级线程，因此只有内核级线程才是处理机分配的单位，所以无法并行



**多对多**模型：n用户级线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程

克服了多对一(并发度不高的缺点，一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点

可以这么理解：

用户级线程是“代码逻辑”的载体

内核级先是“运行机会”的载体

**内核级线程才是处理机分配的单位**，且内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞

## 状态与转换

如图所示，其实线程的状态与转换和进程是类似的，几乎没区别

<img src="https://b.1wind.cn/2025/08/13ec64f48fc42929dd56a38e001a9c12.png" alt="image-20250813145901208" style="zoom:50%;" />

# 调度

## 概念

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定**某种规则**来**决定**处理这些任务的**顺序**，这就是调度研究的问题

## 高级调度

高级调度(作业调度)。按一定的原则从外存的作业后备队列中年挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB

作业：一个具体的任务

用户向系统提交一个作业≈用户让操作系统启动一个程序(来处理一个具体的任务)

## 低级调度

低级调度(进程调度/处理机调度)---按照某种策略从就绪队列中选取一个进程，将处理机分配给它

进程调度是操作系统中最基本的一种调度，在一般的操作系统中年都必须配置进程调度

进程调度的频率很高，一般几十毫秒一次

## 中级调度

内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存

暂时调到外存等待的进程状态为**挂起状态**。被挂起的进程PCB会被组织成**挂起队列**

中级调度(内存调度)---按照某种策略决定将哪个处于挂起状态的进程重新调入内存

一个进程可能会被多次调入和调出，因此中级调度发生的**频率**比高级调度**更高**

## 调度对比

|                          | 要做什么                                                     | 调度发生                   | 发生频率 | 对进程状态的影响                       |
| ------------------------ | ------------------------------------------------------------ | -------------------------- | -------- | -------------------------------------- |
| 高级调度<br />(作业调度) | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存->内存<br />(面向作业) | 最低     | 无->创建态->就绪态                     |
| 中级调度<br />(内存调度) | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存     | 外存->内存<br />(面向进程) | 中等     | 挂起态->就绪态<br />(阻塞挂起->阻塞态) |
| 低级调度<br />(进程调度) | 按照某种规则，从就绪队列中选择一个进程为其分配处理机         | 孽畜->CPU                  | 最高     | 就绪态->运行态                         |

