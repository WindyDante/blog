---
title: 数据结构
tags: 数据结构与算法
date: 2025-4-30 17:11:05

---
# 基本概念

数据是**信息的载体**，是描述客观事物属性的数、字符及**所有能输入到计算机中并被计算机程序识别(二进制0和1)**和处理的符号的集合。数据是计算机程序加工的原料

**数据元素**是数据的基本单位，通常作为一个整体进行考虑和处理

一个数据元素可由若干**数据项**组成，数据项是构成数据元素的不可分割的最小单位

**结构**是各个元素之间的关系

**数据结构**是相互之间存在一种或多种特定关系的数据元素的集合

**数据对象**是具有相同性质的数据元素的集合，是数据的一个子集

# 存储结构

集合：各个元素同属一个集合，别无其他关系

线性结构：数据元素之间是一对一的关系，除了第一个元素，所有元素都有前置元素；除了最后一个元素，所有元素都有后置元素

树形结构：数据元素之间是一对多的关系

图结构：数据元素之间是多对多的关系

顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元，元素之间的关系由存储单元的邻接关系来提现

链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系

索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）

散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储

# 算法

程序 = 数据结构 + 算法

数据结构：如何用数据正确地描述现实世界的问题，并存入计算机

算法：如何高效地处理这些数据，以解决实际问题

算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作

## 特性

- 有穷性。一个算法必须总在有穷步之后结束，且每一步都可在有穷时间内完成。

	- 注：算法必须是有穷的，而程序可以是无穷的

- 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出

- 可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。

- 输入。一个算法有零个或多个输入，这些输入取自某个特定的对象的集合

- 输出。一个算法有一个或多个输出，这些输出是与输入有着特定关系的量

## 度量

### 时间复杂度

如果我们想统计一种功能或者一种算法的使用时间，一般都称这里的时间是：**时间复杂度**

那么，通常计算这个时间，都是让算法先运行，事后统计运行时间

但是这种方案存在一些问题

- 和机器性能有关，越好的机器处理速度越快
- 和编程语言有关，越高级的语言执行效率越低
- 和编译程序产生的机器指令质量有关
- 有些算法是不能事后再统计的，如：导弹控制算法

算法的时间复杂度，通常是通过事前预估算法时间开销T(n)与问题规模n的关系(T表示“time”)

时间复杂度可以只考虑阶数高的部分

加法规则

多项相加，只保留最高阶的项，且系数变为1，譬如O(n) + O(1)，那么只会保留O(n)

常见数量集(从左到右依次递增)

![image-20250601204453712](https://b.1wind.cn/2025/06/d1642e31fa8b8c2d8e83e50bb656c9fd.png)

三种复杂度

- 最坏时间复杂度：考虑输入数据“最坏”的情况
- 平均时间复杂度：考虑所有输入数据都等概率出现的情况
- 最好时间复杂度：考虑输入数据“最好”的情况

通常只考虑最坏时间复杂度和平均时间复杂度的情况

### 空间复杂度

无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为S(n) = O(1)

注：S表示“Space”

# 表

## 线性表

定义：数据结构

基本操作：运算

注：数据结构三要素--逻辑结构、数据的运算、存储结构（物理结构） 存储结构不同，运算的实现方式不同

### 定义

线性表是具有相同(每个数据元素所占空间一样大)数据类型的n(n>=0)个数据元素的有限序列(有次序)，其中n为表长，当n=0时线性表是一个**空表**。若用L命名线性表，则一般表示为->L={a1,a2,ai,ai+1,...,an}

几个概念：

ai是线性表中的“第i个”元素线性表中的**位序**

a1是**表头元素**，an是**表尾元素**

除第一个元素外，每个元素有且仅有一个**直接前驱**；除最后一个元素外，每个元素有且仅有一个**直接后继**

### 基本操作

InitList(&L)：初始化表。构造一个空的线性表L，分配内存空间

DestroyList(&L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间(从无到有，从有到无)

ListInsert(&L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e

ListDelete(&L,i,&e)：删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值

LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素

GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值

其他常用操作：

Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数

PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值

Empty(L)：判空操作。若L为空表，则返回true，否则返回false

## 顺序表

### 定义

线性表是具有**相同**(每个数据元素所占空间一样大)数据类型的n(n>=0)个数据元素的有限序列

顺序表--用**顺序存储**的方式实现线性表顺序存储

把**逻辑相邻**的元素存储在**物理位置上也相邻**的存储单元中，元素之间的关系由存储单元的邻接关系来提现

通常来说，元素位置一般这样计算：

LOC->起始位置

n->第n个数

size->数据元素大小

第n个值的位置->LOC(L) + (n-1) * size

### 动态分配

声明结构体及头文件

```c
#include <stdlib.h>
#define InitSize 10	// 默认的最大长度
typedef struct{
	// 指示动态分配数组的指针,这里的int可以改为任意的elementType，当然，后面对应的参数也需要同步修改
	int *data;	
	int MaxSize;	// 顺序表最大容量
	int length;		// 顺序表的当前长度
}SeqList;
```

初始化列表

```c
void InitList(SeqList &L){
	// 用malloc 函数申请一片连续的存储空间
    // 初始化容量*类型大小 = 总空间
	L.data = (int *)malloc(InitSize*sizeof(int));
    // 声明数组长度
	L.length = 0;
    // 声明最大容量
	L.MaxSize = InitSize;
}
```

增加动态数组的长度

```c
void IncreaseSize(SeqList &L,int len){
    // 将旧数据copy
	int *p = L.data;
    //  开辟新空间
	L.data = (int *)malloc((L.MaxSize+len)*sizeof(int));
    for (int i=0;i < L.length;i++){
        // 将数据复制到新区域
        L.data[i] = p[i]
    }
    L.MaxSize = L.MaxSize + len;	// 将顺序表最大长度增加len
    free(p);	// 释放旧空间
}
```

main函数启动

```c
int main(){
	SeqList L;	//声明顺序表
	InitList(L);	//初始化顺序表
	// 插入元素...
	IncreaseSize(L, 5)
	return 0;
}
```

### 特点

1. 随机访问,即可以在O(1)时间内找到第i个元素
2. 存储密度高,每个节点只存储数据元素
3. 拓展容量不方便(即便采用动态分配的方式实现,拓展长度的时间复杂度也比较高)
4. 插入、删除操作不方便。需要移动大量元素

### 基本操作

#### 插入

ListInsert(&L,i,e):插入操作。在表L中的第i个位置上插入指定元素e

这里采用静态分配方式实现的顺序表

静态分配是指在程序编译时，变量或数据结构所需要的内存空间就已经确定，并在程序运行期间保持不变

```c
#define MaxSize 10	// 定义最大长度
typedef struct{
	ElemType data[MaxSize];	// 用静态的“数组”存放数据元素
	int length;	// 顺序表的长度
}SqList;	// 顺序表的类型定义
```

![image-20250604143203403](https://b.1wind.cn/2025/06/16ae89cf0664db6d4987f6231a0def62.png)

具体操作

```c
void ListInsert(SqlList &L,int i,int e){
	for(int j=L.length;j>=i;j--)	// 将第i个元素及之后的元素后移
		L.data[j]=L.data[j-1]
	L.data[i-1]=e;	// 在位置i处放入e
    L.length++;	// 长度+1
}
```

假设数组L内有元素{1,2,3},希望在第2个位置上插入4

那么，当前操作将会先让数组后移，若位置为2，则在索引1的位置上赋值，因为具体数据已经后移了，所以可以直接放入{1,4,2,3},再将长度+1

但是这种代码有一定的问题，比如元素满了，索引错误等，这里给出一个相对来说比较好的示例

```c
bool ListInsert(SqList &L,int i,int e){
	if (i < 1|| i > L.length+1)	// 判断i的范围是否有效
		return false;
	if (L.length>=MaxSize)	// 查看当前存储空间是否已满
		return false;
	for(int j=L.length;j>=i;j--)	// 元素后移
		L.data[j]=L.data[j-1]
	L.data[i-1]=e;	// 放入e
	L.length++;	// 长度+1
	return true;
}
```

**好的算法,应该具有健壮性.能够处理异常情况,并给使用者反馈**

#### 删除

ListDelete(&L,i,&e)：删除操作。删除表L中**第i个**位置的元素，并用e返回删除元素的值

![image-20250604152226398](https://b.1wind.cn/2025/06/3182ac55d89bccd567d4e3771f6d0ab7.png)

```c
bool ListDelete(SqList &L,int i,int &e){
	if (i < 1 || i>L.length)	// 判断i的范围是否有效
		return false;
	e=L.data[i-1]	// 将被删除的元素赋值给e
	for(int j=i;j<L.length;j++)	// 将第i个位置后的元素前移
		L.data[j-1]=L.data[j];
	L.length--;	//长度-1
	return true;
}
```

假设数组L中有元素{1,2,3},要被删除的是第二个元素，那么e则得到了L.data[1]，则是2

将第i个位置后的元素后移，则是2后面的元素前移

L.data[1]=Ldata[2],所以3移动到2的位置上，实现删除

#### 查找

静态分配及动态分配

GetElem(L,i)：按位查找操作。获取表L中**第i个位置**的元素的值

```c
ElemType GetElem(SqList L,int i){
	return L.data[i-1];
}
```

LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素

```c
// 在顺序表L中查找第一个元素值等于e的元素，并返回其位序
int LocateElem(SeqList L,int e){
	for(int i=0;i<L.length;i++)
		return i+1;
	return 0;
}
```

## 链表

### 单链表

存储结构图如下

<img src="https://b.1wind.cn/2025/06/143319fe7daa08e1f75130705c5fe5d0.png" alt="image-20250604204456362" style="zoom:50%;" />

```c
struct LNode{	// 定义单链表结点类型
	ElemType data;	// 每个节点存放一个数据元素
	struct LNode *next;	// 指针指向下一个节点
}
```

- LNode：结点
- data：数据域
- next：指针域

`struct LNode *p = (struct LNode*)malloc(sizeof(struct LNode));` 增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点

typedef 是 可以将某些类型改名的一种方式

通常`typedef 类型 名称`->譬如`typedef int zhengshu`，我们就可以使用`zhengshu a = 1;`来声明一个整数

那么我们也可以`typedef struct LNode LNode`、`typedef struct LNode *LinkList`

此时，要表示一个单链表时，只需声明一个**头指针**L，指向单链表的第一个节点

`LNode * L`->`声明一个指向单链表第一个节点的指针`

`LinkList L`->`声明一个指向单链表第一个节点的指针`(代码可读性更强)

强调这是一个单链表 -->使用LinkList

强调这是一个结点  -->使用LNode*

#### 不带头节点

```c
typedef struct LNode{	// 定义单链表节点类型
	ElemType data;	// 每个节点存放一个数据元素
	struct LNode *next;	//指针指向下一个节点
}LNode,*LinkList

//初始化一个空的单链表
bool InitList(LinkList &L){
    L = NULL;	// 空表，暂时还没有任何节点(防止脏数据)
    return true;
}

void test(){
    LinkList L;	//声明一个指向单链表的指针(注意，此处并没有创建一个结点)
    //初始化一个空表
    InitList(L);
}

// 判断单链表是否为空
bool Empty(LinkList L){
    return (L==NULL);
}
```

#### 带头节点

```c
typedef struct LNode{	// 定义单链表节点类型
	ElemType data;	// 每个节点存放一个数据元素
	struct LNode *next;	//指针指向下一个节点
}LNode,*LinkList

//初始化一个单链表(带头节点)
bool InitList(LinkList &L){
    L = (LNode *) malloc(sizeof(LNode));	//分配一个头节点
    if (L == NULL)
        return false;	//内存不足，分配失败
    L->next = NULL;	//头节点后暂无节点
    return true;
}

void test(){
    LinkList L;	//声明一个指向单链表的指针(注意，此处并没有创建一个结点)
    //初始化一个空表
    InitList(L);
}
```

